import math
import numpy as np
import numpy.linalg as npla
import toolbox.matrixtoolbox as mtb
from itertools import product
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from mpl_toolkits.mplot3d import art3d
    
class generaltoolbox:
    
    @staticmethod
    def decimal_to_fraction(x,n=2):
        #This method converts a decimal x rounded off to the nth decimal place
        #into a list containing it's numerator and denominator (in that order). 
        if not isinstance(n,int):
            n=int(n)
        if x==0.0:
            num=0
            den=1
        else:
            x=round(x,n)
            num=round(x*10**n)
            den=10**n
            
            c2=0
            while round(num)%2==0 and c2<n:
                num/=2
                den/=2
                c2+=1
            c5=0
            while round(num)%5==0 and c5<n:
                num/=5
                den/=5
                c5+=1
        return [int(num),int(den)]
    
    @staticmethod
    def colors(N,plotly=False):
        #This method producesa list of N evenly-spaced color strings used for plotting.
        #The plotly option converts those colors to rgb strings compatible with 
        #plotly plotting methods.
        N=int(round(N))
        if N<=0:
            return []
        elif N==1:
            if plotly:
                return ["rgb(0,0,0)"]
            else:
                return ["black"]
        elif N==2:
            if plotly:
                return ["rgb(255,0,0)","rgb(0,0,255)"]
            else:
                return ["red","blue"]
        elif N==3:
            if plotly:
                return ["rgb(255,0,0)","rgb(0,255,0)","rgb(0,0,255)"]
            else:
                return ["red","green","blue"]
        elif N==4:
            if plotly:
                return ["rgb(255,0,0)","rgb(255,255,0)","rgb(0,255,255)","rgb(0,255)"]
            else:
                return ["red","yellow","cyan","blue"]
        else:
            res=[]
            for i in range(N):
                col=i/(N-1)
                if 0<=col<0.2:
                    #red-yellow
                    if plotly:
                        res.append("rgb(255,"+str(round(255*5*col))+",0)")
                    else:
                        res.append([1,5*col,0])
                elif 0.2<=col<0.4:
                    #yellow-green
                    if plotly:
                        res.append("rgb("+str(round(255*(1-5*(col-0.2))))+",255,0)")
                    else:
                        res.append([1-5*(col-0.2),1,0])
                elif 0.4<=col<0.6:
                    #green-cyan
                    if plotly:
                        res.append("rgb(0,255,"+str(round(255*5*(col-0.4)))+")")
                    else:
                        res.append([0,1,5*(col-0.4)])
                elif 0.6<=col<0.8:
                    #cyan-blue
                    if plotly:
                        res.append("rgb(0,"+str(round(255*(1-5*(col-0.6))))+",255)")
                    else:
                        res.append([0,1-5*(col-0.6),1])
                elif 0.8<=col<=1:
                    #blue-magenta
                    if plotly:
                        res.append("rgb("+str(round(255*5*(col-0.8)))+",0,255)")
                    else:
                        res.append([5*(col-0.8),0,1])
            return res
    
    @staticmethod
    def hammersley(N,dim,points=True):
        #This method produces N psuedo-random Hammersley points of dimension dim.
        #The points option selects how the points are returned: either as a list
        #of points, or as a list of coordinate lists.
        primes=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137]
        B=primes[:dim]
        dim=len(B)
        def Phi(k,b):
            bprime=b
            kprime=k
            phi=0
            while kprime>0:
                a=float(kprime%b)
                phi+=a/bprime
                kprime=int(kprime/b)
                bprime=bprime*b
            return phi
        if points:
            return [np.array([n/N]+[Phi(n,B[i-1]) for i in range(1,dim)]) for n in range(N+1)]
        else:
            return [np.array([n/N for n in range(N+1)])]+[np.array([Phi(n,B[i-1]) for n in range(N+1)]) for i in range(1,dim)]
    
    @staticmethod
    def differentiate(f,x,args=[],kwargs={},h=1e-3,variableDim=1):
        #This method approximates the (partial) derivative of function f:R^n->R
        #at point x with respect the the (variableDim)th variable,
        #using a 5-point-stencil whenever possible.
        
        if ("int" in type(x).__name__) or ("float" in type(x).__name__):
            x2hminus=x-2*h
            xhminus=x-h
            xhplus=x+h
            x2hplus=x+2*h
        elif ("list" in type(x).__name__):
            variableDim=max(min(variableDim,len(x)),0)
            x2hminus=x[:variableDim]+[x[variableDim]-2*h]+x[variableDim+1:]
            xhminus=x[:variableDim]+[x[variableDim]-h]+x[variableDim+1:]
            xhplus=x[:variableDim]+[x[variableDim]+h]+x[variableDim+1:]
            x2hplus=x[:variableDim]+[x[variableDim]+2*h]+x[variableDim+1:]
        elif ("tuple" in type(x).__name__):
            variableDim=max(min(variableDim,len(x)),0)
            x2hminus=x[:variableDim]+tuple([x[variableDim]-2*h])+x[variableDim+1:]
            xhminus=x[:variableDim]+tuple([x[variableDim]-h])+x[variableDim+1:]
            xhplus=x[:variableDim]+tuple([x[variableDim]+h])+x[variableDim+1:]
            x2hplus=x[:variableDim]+tuple([x[variableDim]+2*h])+x[variableDim+1:]
        elif ("ndarray" in type(x).__name__):
            variableDim=max(min(variableDim,len(x)),0)
            x2hminus=np.concatenate([x[:variableDim],[x[variableDim]-2*h],x[variableDim+1:]])
            xhminus=np.concatenate([x[:variableDim],[x[variableDim]-h],x[variableDim+1:]])
            xhplus=np.concatenate([x[:variableDim],[x[variableDim]+h],x[variableDim+1:]])
            x2hplus=np.concatenate([x[:variableDim],[x[variableDim]+2*h],x[variableDim+1:]])
        else:
            print("Error: point x is of an incompatible type %s"%type(x).__name__)
            return None
        
        try:
            fx=f(x,*args,**kwargs)
        except:
            print("Error: Function is not defined on point x")
            return None
        
        try:
            fx2hminus=f(x2hminus,*args,**kwargs)
            fx2hplus=f(x2hplus,*args,**kwargs)
            try:
                fxhminus=f(xhminus,*args,**kwargs)
                fxhplus=f(xhplus,*args,**kwargs)
                return (-fx2hplus+8*fxhplus-8*fxhminus+fx2hminus)/(12*h)
            except:
                return (fx2hplus-fx2hminus)/(4*h)
        except:
            try:
                fxhminus=f(xhminus,*args,**kwargs)
                try:
                    fxhplus=f(xhplus,*args,**kwargs)
                    return (fxhplus-fxhminus)/(2*h)
                except:
                    return (fx-fxhminus)/h
            except:
                try:
                    fxhplus=f(xhplus,*args,**kwargs)
                    return (fxhplus-fx)/h
                except:
                    print("Error: Function can not be differentiated in point ["+", ".join([str(elem) for elem in x])+"]")
                    return None
    
    @staticmethod
    def integrate(f,start,stop,args=[],kwargs={},mode="gauss",maxlevel=5,errtol=1e-3,adapt=True):
        #This method approximates the integral of a function f:R->R between the lower bound
        #start and upper bound stop. The integral can be computed using either 
        #the adaptive (G30,K61) Gauss-Kronrod quadrature or the adaptive trapezium method.
        #The maxlevel variable determines how many times the adaptive method can
        #iterate, while the errtol variable provides an additional stopping
        #criterion.
        maxlevel=int(round(maxlevel))
        if (("int" not in type(start).__name__) and ("float" not in type(start).__name__)) or (("int" not in type(stop).__name__) and ("float" not in type(stop).__name__)):
            print("Error: inputted upper bound b or lower bound a are of incompatible type")
            print("Type of lower bound a: %s"%type(start).__name__)
            print("Type of upper bound b: %s"%type(stop).__name__)
            return None
        
        start=min(start,stop)
        stop=max(start,stop)
        
        if start==stop:
            return 0.0
        elif "gauss" in mode.lower() or "kronrod" in mode.lower():
            F=0.0
            xg=[-0.9968934840746495,-0.9836681232797472,-0.9600218649683075,
                -0.9262000474292743,-0.8825605357920527,-0.8295657623827684,
                -0.7677774321048262,-0.6978504947933158,-0.6205261829892429,
                -0.5366241481420199,-0.44703376953808915,-0.3527047255308781,
                -0.25463692616788985,-0.15386991360858354,-0.0514718425553177,
                0.0514718425553177,0.15386991360858354,0.25463692616788985,
                0.3527047255308781,0.44703376953808915,0.5366241481420199,
                0.6205261829892429,0.6978504947933158,0.7677774321048262,
                0.8295657623827684,0.8825605357920527,0.9262000474292743,
                0.9600218649683075,0.9836681232797472,0.9968934840746495]
            wg=[0.007968192496166605,0.01846646831109096,0.02878470788332337,
                0.03879919256962705,0.04840267283059405,0.057493156217619065,
                0.06597422988218049,0.0737559747377052,0.08075589522942021,
                0.08689978720108298,0.09212252223778612,0.09636873717464425,
                0.09959342058679527,0.1017623897484055,0.10285265289355884,
                0.10285265289355884,0.1017623897484055,0.09959342058679527,
                0.09636873717464425,0.09212252223778612,0.08689978720108298,
                0.08075589522942021,0.0737559747377052,0.06597422988218049,
                0.057493156217619065,0.04840267283059405,0.03879919256962705,
                0.02878470788332337,0.01846646831109096,0.007968192496166605]
            xk=[-0.9994844100504906,-0.9968934840746495,-0.9916309968704046,
                -0.9836681232797472,-0.9731163225011262,-0.9600218649683075,
                -0.94437444474856,-0.9262000474292743,-0.9055733076999078,
                -0.8825605357920527,-0.8572052335460612,-0.8295657623827684,
                -0.799727835821839,-0.7677774321048262,-0.7337900624532268,
                -0.6978504947933158,-0.6600610641266269,-0.6205261829892429,
                -0.5793452358263617,-0.5366241481420199,-0.49248046786177857,
                -0.44703376953808915,-0.4004012548303944,-0.3527047255308781,
                -0.30407320227362505,-0.25463692616788985,-0.20452511668230988,
                -0.15386991360858354,-0.10280693796673702,-0.0514718425553177,
                0.0,0.0514718425553177,0.10280693796673702,0.15386991360858354,
                0.20452511668230988,0.25463692616788985,0.30407320227362505,
                0.3527047255308781,0.4004012548303944,0.44703376953808915,
                0.49248046786177857,0.5366241481420199,0.5793452358263617,
                0.6205261829892429,0.6600610641266269,0.6978504947933158,
                0.7337900624532268,0.7677774321048262,0.799727835821839,
                0.8295657623827684,0.8572052335460612,0.8825605357920527,
                0.9055733076999078,0.9262000474292743,0.94437444474856,
                0.9600218649683075,0.9731163225011262,0.9836681232797472,
                0.9916309968704046,0.9968934840746495,0.9994844100504906]
            wk=[0.0013890136986770077,0.003890461127099884,0.0066307039159312926,
                0.009273279659517764,0.011823015253496341,0.014369729507045804,
                0.01692088918905327,0.019414141193942382,0.021828035821609193,
                0.0241911620780806,0.0265099548823331,0.02875404876504129,
                0.030907257562387762,0.03298144705748372,0.034979338028060025,
                0.03688236465182123,0.038678945624727595,0.040374538951535956,
                0.041969810215164244,0.04345253970135607,0.04481480013316266,
                0.04605923827100699,0.04718554656929915,0.04818586175708713,
                0.04905543455502978,0.04979568342707421,0.05040592140278235,
                0.05088179589874961,0.051221547849258774,0.05142612853745902,
                0.05149472942945157,0.05142612853745902,0.051221547849258774,
                0.05088179589874961,0.05040592140278235,0.04979568342707421,
                0.04905543455502978,0.04818586175708713,0.04718554656929915,
                0.04605923827100699,0.04481480013316266,0.04345253970135607,
                0.041969810215164244,0.040374538951535956,0.038678945624727595,
                0.03688236465182123,0.034979338028060025,0.03298144705748372,
                0.030907257562387762,0.02875404876504129,0.0265099548823331,
                0.0241911620780806,0.021828035821609193,0.019414141193942382,
                0.01692088918905327,0.014369729507045804,0.011823015253496341,
                0.009273279659517764,0.0066307039159312926,0.003890461127099884,
                0.0013890136986770077]
            
            gauss=lambda start,stop:0.5*(stop-start)*sum([wg[i]*f(0.5*((stop-start)*xg[i]+(stop+start)),*args,**kwargs) for i in range(len(wg))])
            kronrod=lambda start,stop:0.5*(stop-start)*sum([wk[i]*f(0.5*((stop-start)*xk[i]+(stop+start)),*args,**kwargs) for i in range(len(wk))])
            if adapt:
                intervals=[[start,stop]]
                intervalErr=[abs(kronrod(intervals[0][0],intervals[0][1])
                                -gauss(intervals[0][0],intervals[0][1]))]
                totalErr=intervalErr[0]
                intlength=abs(intervals[0][1]-intervals[0][0])
                iteratebool=True
                count=0
                while iteratebool and count<=round(2**maxlevel):
                    if totalErr>errtol:
                        splitintervalindex=[]
                        for i in range(len(intervals)):
                            if math.log(intlength/abs(intervals[i][1]-intervals[i][0]),2)<maxlevel:
                                splitintervalindex.append(i)
                        if len(splitintervalindex)>0:
                            i=splitintervalindex[0]
                            for j in range(1,len(splitintervalindex)):
                                if intervalErr[splitintervalindex[j]]>intervalErr[i]:
                                    i=splitintervalindex[j]
                            aInterval=intervals[i][0]
                            bInterval=(intervals[i][1]+intervals[i][0])/2
                            cInterval=intervals[i][1]
                            del intervals[i]
                            del intervalErr[i]
                            intervals.append([aInterval,bInterval])
                            intervals.append([bInterval,cInterval])
                            intervalErr.append(abs(kronrod(aInterval,bInterval)-gauss(aInterval,bInterval)))
                            intervalErr.append(abs(kronrod(bInterval,cInterval)-gauss(bInterval,cInterval)))
                            totalErr=sum(intervalErr)
                        else:
                            iteratebool=False
                    else:
                        iteratebool=False
                    count+=1
                F=sum([kronrod(interval[0],interval[1]) for interval in intervals])
            else:
                F=kronrod(start,stop)
            return F
        else:
            F=0.0
            trapezoid=lambda x1,x2:0.5*(f(x2,*args,**kwargs)+f(x1,*args,**kwargs))*(x2-x1)
            if adapt:
                intervals=[[start,stop]]
                intervalErr=[abs(trapezoid(0.5*(intervals[0][1]+intervals[0][0]),intervals[0][1])
                                +trapezoid(intervals[0][0],0.5*(intervals[0][1]+intervals[0][0]))
                                -trapezoid(intervals[0][0],intervals[0][1]))]
                totalErr=intervalErr[0]
                intlength=abs(intervals[0][1]-intervals[0][0])
                iteratebool=True
                count=0
                while iteratebool and count<=round(2**maxlevel):
                    if totalErr>errtol:
                        splitintervalindex=[]
                        for i in range(len(intervals)):
                            if math.log(intlength/abs(intervals[i][1]-intervals[i][0]),2)<maxlevel:
                                splitintervalindex.append(i)
                        if len(splitintervalindex)>0:
                            i=splitintervalindex[0]
                            for j in range(1,len(splitintervalindex)):
                                if intervalErr[splitintervalindex[j]]>intervalErr[i]:
                                    i=splitintervalindex[j]
                            aInterval=intervals[i][0]
                            bInterval=0.5*(intervals[i][1]+intervals[i][0])
                            cInterval=intervals[i][1]
                            del intervals[i]
                            del intervalErr[i]
                            intervals.append([aInterval,bInterval])
                            intervals.append([bInterval,cInterval])
                            intervalErr.append(abs(trapezoid(aInterval,0.5*(bInterval+aInterval))+trapezoid(0.5*(bInterval+aInterval),bInterval)-trapezoid(aInterval,bInterval)))
                            intervalErr.append(abs(trapezoid(bInterval,0.5*(cInterval+bInterval))+trapezoid(0.5*(cInterval+bInterval),cInterval)-trapezoid(bInterval,cInterval)))
                            totalErr=sum(intervalErr)
                        else:
                            iteratebool=False
                    else:
                        iteratebool=False
                    count+=1
                F=sum([trapezoid(interval[0],interval[1]) for interval in intervals])
            else:
                for i in range(100):
                    F+=trapezoid(start+i*(stop-start)/100,start+(i+1)*(stop-start)/100)
            return F
    
    @staticmethod
    def multiIntegrate(f,start,stop,args=[],kwargs={},N=1e3):
        #This method approximates the integral of a function f:R^n->R between the lower bound
        #vector start and upper bound B. The integral is computed using the quasi-random
        #Monte Carlo integration, with the MonteCarloPoints variable accounting for
        #the precision of the approximation.
        if (("list" in type(start).__name__) or ("ndarray" in type(start).__name__)) and (("list" in type(stop).__name__) or ("ndarray" in type(stop).__name__)):
            if len(start)==len(stop):
                dim=len(start)
                if dim>0 and all([("int" in type(a).__name__) or ("float" in type(a).__name__) for a in start]) and all([("int" in type(b).__name__) or ("float" in type(b).__name__) for b in stop]):
                    for i in range(dim):
                        start[i]=min(start[i],stop[i])
                        stop[i]=max(start[i],stop[i])
                else:
                    print("Error: inputted upper bound vector stop or lower bound start contains incompatible element types")
                    print("Types in lower bound start: %s"%", ".join([type(a).__name__ for a in start]))
                    print("Types in upper bound stop: %s"%", ".join([type(b).__name__ for b in stop]))
                    return None
            else:
                print("Error: Lower bound vector start and upper bound vector stop are of different sizes")
                return None
        else:
            print("Error: inputted upper bound vector stop or lower bound start are of incompatible type")
            print("Type of lower bound start: %s"%type(start).__name__)
            print("Type of upper bound stop: %s"%type(stop).__name__)
            return None
        
        if ("int" not in type(N).__name__) and ("float" not in type(N).__name__):
            print("Error: N is of incompatible type")
            print("Type of N: %s"%type(N).__name__)
            return None
        
        N=int(round(N))
        npA=np.array(start)
        npB=np.array(stop)
        Points=generaltoolbox.hammersley(N,dim)
        return np.prod(npB-npA)*sum([f(npA+Points[i]*(npB-npA),*args,**kwargs) for i in range(N)])/N
    
    @staticmethod
    def interpolate(sol,t,N):
        #This method interpolates a set of data (sol,t) into N temporally
        #evenly-spaced data points.
        dim=len(sol)
        n=len(t)
        if any(len(sol[i])!=n for i in range(dim)):
            print("Error: check the length of your inputted vectors")
            for i in range(dim):
                print("Length of sol[%i]: %i"%(i,len(sol[i])))
            print("Length of t: %i"%len(t))
            return [], []
        
        tprime=np.linspace(t[0],t[n-1],N)
        solprime=[[sol[i][0]]+[0 for j in range(N-1)] for i in range(dim)]
        index=0
        for i in range(1,N):
            for j in range(index,n):
                if abs(t[j]-tprime[i])<=1e-6:
                    index=j
                    for k in range(dim):
                        solprime[k][i]=sol[k][index]
                    break
                if abs(t[j]-tprime[i-1])>=abs(tprime[i]-tprime[i-1]):
                    index=j
                    for k in range(dim):
                        if n>2:
                            if j==n-1:
                                solprime[k][i]=(sol[k][j-2]*(tprime[i]-t[j-1])*(tprime[i]-t[j])/((t[j-2]-t[j-1])*(t[j-2]-t[j]))
                                                +sol[k][j-1]*(tprime[i]-t[j-2])*(tprime[i]-t[j])/((t[j-1]-t[j-2])*(t[j-1]-t[j]))
                                                +sol[k][j]*(tprime[i]-t[j-2])*(tprime[i]-t[j-1])/((t[j]-t[j-2])*(t[j]-t[j-1])))
                            else:
                                solprime[k][i]=(sol[k][j-1]*(tprime[i]-t[j])*(tprime[i]-t[j+1])/((t[j-1]-t[j])*(t[j-1]-t[j+1]))
                                                +sol[k][j]*(tprime[i]-t[j-1])*(tprime[i]-t[j+1])/((t[j]-t[j-1])*(t[j]-t[j+1]))
                                                +sol[k][j+1]*(tprime[i]-t[j-1])*(tprime[i]-t[j])/((t[j+1]-t[j-1])*(t[j+1]-t[j])))
                        else:
                            solprime[k][i]=sol[k][j-1]*(t[j]-tprime[i])/(t[j]-t[j-1])+sol[k][j]*(tprime[i]-t[j-1])/(t[j]-t[j-1])
                    break
        return solprime,tprime
    
    @staticmethod
    def newtonRaphson(f,start,stop,delta,args=[],kwargs={},errtol=1e-3,neighborhoodRange=1e-2,maxlevel=50,speed=1):
        #This method uses the multidimensional Newton-Raphson method to approximate
        #the zeros of function f between lower bound vector start and upper bound vector
        #stop. The method divides the search space into equally-sized spaces whose
        #dimensions are given in vector delta. The method will search in each subspace,
        #iterating a maximum of maxLevel times and each solution found must reach
        #the errtol given. Solutions too close to each other are filtered out,
        #determined by the neighborhoodRange variable. Finally, the speed variable allows
        #for potentially faster convergence (if speed>1) or more steady convergence
        #(if speed<1)
        try:
            dim=len(start)
        except TypeError:
            dim=1
        try:
            fdim=len(f(start,*args,**kwargs))
        except TypeError:
            fdim=1
            
        if speed<=0:
            speed=1
        N=[max(round((stop[i]-start[i])/delta[i]),1) for i in range(dim)]
        res=[]
        grid=[[start[i]+delta[i]/2+j*(stop[i]-start[i])/N[i] for j in range(N[i])] for i in range(dim)]
        vectarray=[np.array(elem) for elem in product(*grid)]
        
        for v in vectarray:
            vect=v.copy()
            diff=[]
            count=0
            while count<maxlevel and sum([f(vect,*args,**kwargs)[j]**2 for j in range(fdim)])>errtol**2:
                A=mtb.jacobian(f,vect,args=args,kwargs=kwargs)
                inv=mtb.LU(A,-np.array(f(vect,*args,**kwargs)))
                if len(inv)>0:
                    diff=speed*inv
                    vect=vect+diff
                    count+=1
                else:
                    if npla.norm(f(vect,*args,**kwargs))>1e-2:
                        count=maxlevel
                    break
            
            skip=False
            for r in res:
                if any([abs(vect[k]-r[k])<neighborhoodRange*np.prod(delta) for k in range(dim)]):
                    skip=True
                    r=(vect+r)/2.0
                    break
            if not skip:
                if 0<=count<maxlevel:
                    if all([start[i]<=vect[i]<=stop[i] for i in range(dim)]):
                        res.append(vect)
        return res
    
    @staticmethod
    def pointplot(f,start,stop,delta,args=[],kwargs={},adapt=True,maxlevel=10,mode="linear",plotbool=True,plotaxis=None,colormap=None,color="black",alpha=1.0):
        #This method approximates the 0D solutions of f(x)=0, using a 
        #"marching-line" algorithm, which is a 1D form of the marching cube algorithm.
        #The zeros are found between scalar lower bound start and scalar upper bound
        #stop, and divided into subsections of length delta. The method can subdivide
        #even further through variable adapt. The method then bisects each subsection
        #and only focusses on subsections that, as best as the method can tell, do 
        #not contain any solutions. The subsections then form a structure similar to
        #a sparse bitree. The maximum level of subdivisions is determined by variable
        #maxlevel. After subdivision, the zeros are approximated using either linear,
        #quadratic, or cubic interpolation, determined by variable mode. A colormap option
        #is available to when plotting (colormap values are based on the x-coordinate).
        plotshowbool=False
        if plotbool and plotaxis is None:
            graphsize=9
            font = {"family": "serif",
                "color": "black",
                "weight": "bold",
                "size": "20"}
            plotfig=plt.figure(figsize=(graphsize,graphsize))
            plotaxis=plotfig.add_subplot(111)
            plotaxis.set_title("Function Point",fontdict=font)
            plotaxis.set_xlabel("$\\mathbf{X}$",fontsize=16,rotation=0)
            plotaxis.set_ylabel("$\\mathbf{Y}$",fontsize=16,rotation=0)
            plotaxis.xaxis.set_tick_params(labelsize=16)
            plotaxis.yaxis.set_tick_params(labelsize=16)
            plotshowbool=True
            
        paths=[[[]],
               [[0,1]],
               [[0,1]],
               [[]]]
        
        class line:
            def __init__(self,Sv1,delta,f):
                self.delta=delta
                self.V=[Sv1,Sv1+delta]
                self.c=0.5*(self.V[0]+self.V[1])
                self.err=1e-3*(self.V[1]-self.V[0])
                self.zero=0.0#1e-6*self.delta
                self.f=f
                self.F=[0 for i in range(2)]
                self.fc=0
                self.full=False
                self.done=False
                self.Px=[]
            
            def adjust(self,a,fa,b=None):
                shift=100
                tempa=a
                tempfa=fa
                if math.isinf(fa) or math.isnan(fa):
                    i=1
                    if b is None:
                        b=0.5*(self.V[0]+self.V[1])
                    tempa=a+(b-a)/shift
                    tempfa=self.f(tempa,*args,**kwargs)
                    abool=math.isinf(tempfa) or math.isnan(fa)
                    while abool and i<shift-1:
                        i+=1
                        tempa=a+(b-a)*i/shift
                        tempfa=self.f(tempa,*args,**kwargs)
                        abool=math.isinf(tempfa) or math.isnan(fa)
                    if abool:
                        tempa=a
                        tempfa=fa
                return tempa,tempfa
            
            def intersect(self,a,b,fa,fb,P,mode):
                if mode.lower() in ["quad","quadratic","2","two","second"]:
                    c,fc=self.adjust(self.c,self.f(self.c,*args,**kwargs))
                    A=((b-c)*fa+(c-a)*fb+(a-b)*fc)/((a-b)*(a-c)*(b-c))
                    B=((c**2-b**2)*fa+(a**2-c**2)*fb+(b**2-a**2)*fc)/((a-b)*(a-c)*(b-c))
                    C=((b-c)*b*c*fa+(c-a)*c*a*fb+(a-b)*a*b*fc)/((a-b)*(a-c)*(b-c))
                    R=np.roots([A,B,C])
                    res=0
                    rcount=0
                    for r in R:
                        if abs(r.imag)<=self.zero:
                            if abs(a-r.real)<=self.err:
                                res+=a
                                rcount+=1
                            elif abs(b-r.real)<=self.err:
                                res+=b
                                rcount+=1
                            else:
                                if a<r.real<b:
                                    res+=r.real
                                    rcount+=1
                                elif a>r.real>b:
                                    res+=r.real
                                    rcount+=1
                    if rcount>0:
                        P.append(res/rcount)
                        
                elif mode.lower() in ["cube","cubic","3","three","third"]:
                    h=1e-3*self.delta
                    aplus=a+h
                    aminus=a-h
                    bplus=b+h
                    bminus=b-h
                    
                    faplus=self.f(aplus,*args,**kwargs)
                    aplus,faplus=self.adjust(aplus,faplus)
                    faminus=self.f(aminus,*args,**kwargs)
                    aminus,faminus=self.adjust(aminus,faminus)
                    fbplus=self.f(bplus,*args,**kwargs)
                    bplus,fbplus=self.adjust(bplus,fbplus)            
                    fbminus=self.f(bminus,*args,**kwargs)
                    bminus,fbminus=self.adjust(bminus,fbminus)
                    
                    faprime=(faplus-faminus)/(2*h)
                    fbprime=(fbplus-fbminus)/(2*h)
                        
                    A=(a*faprime+a*fbprime-b*faprime-b*fbprime-2*fa+2*fb)/((a-b)**3)
                    B=(-a**2*faprime-2*a**2*fbprime-a*b*faprime+a*b*fbprime+3*a*fa-3*a*fb+2*b**2*faprime+b**2*fbprime+3*b*fa-3*b*fb)/((a-b)**3)
                    C=(a**3*fbprime+2*a**2*b*faprime+a**2*b*fbprime-a*b**2*faprime-2*a*b**2*fbprime-6*a*b*fa+6*a*b*fb-b**3*faprime)/((a-b)**3)
                    D=(-a**3*b*fbprime+a**3*fb-a**2*b**2*faprime+a**2*b**2*fbprime-3*a**2*b*fb+a*b**3*faprime+3*a*b**2*fa-b**3*fa)/((a-b)**3)
                    R=np.roots([A,B,C,D])
                    res=0
                    rcount=0
                    for r in R:
                        if abs(r.imag)<=self.zero:
                            if abs(a-r.real)<=self.err:
                                res+=a
                                rcount+=1
                            elif abs(b-r.real)<=self.err:
                                res+=b
                                rcount+=1
                            else:
                                if a<r.real<b:
                                    res+=r.real
                                    rcount+=1
                                elif a>r.real>b:
                                    res+=r.real
                                    rcount+=1
                    if rcount>0:
                        P.append(res/rcount)
                else:
                    temp=(a*fb-b*fa)/(fb-fa)
                    P.append(temp)
            
            def calc(self):
                for i in range(2):
                    v,fv=self.adjust(self.V[i],self.f(self.V[i],*args,**kwargs))
                    self.F[i]=fv
                self.c,self.fc=self.adjust(self.c,self.f(self.c,*args,**kwargs),b=self.V[0])
                self.full=True
                for fv in self.F:
                    if abs(fv)>self.zero:
                        self.full=False
                        break
                
                if not self.full:
                    if all([fv<0 for fv in self.F]) or all([fv>0 for fv in self.F]):
                        self.done=True
                        for i in range(2):
                            if self.F[i]*self.fc<0:
                                self.done=False
                                break
                    
            def split(self,S):
                if not self.done and not self.full:
                    splitS=[]
                    for s in [line(0.5*(self.V[0]+self.V[i]),self.delta/2,f) for i in range(2)]:
                        s.calc()
                        if not s.done:
                            splitS.append(s)
                    S+=splitS
                elif self.full:
                    S+=[self]
                    
            def findpoints(self):
                if not self.done:
                    if not self.full:
                        index=0
                        for i in range(2):
                            if self.F[i]<=self.zero:
                                index+=2**(1-i)
                        path=paths[index]
                        for p in path:
                            if len(p)>1:
                                self.intersect(self.V[0],self.V[1],self.F[0],self.F[1],self.Px,mode)
                    
            def draw(self,plotaxis):
                if not self.done:
                    if self.full:
                        if colormap is not None:
                            try:
                                plotaxis.plot([self.V[0],self.V[1]],[0,0],color=colormap((0.5*(self.V[1]+self.V[0])-start)/(stop-start)),alpha=alpha)
                            except:
                                plotaxis.plot([self.V[0],self.V[1]],[0,0],color=color,alpha=alpha)
                        else:
                            plotaxis.plot([self.V[0],self.V[1]],[0,0],color=color,alpha=alpha)
                        
        if adapt:
            delta=max((stop-start)/10,delta)
        else:
            delta=max((stop-start)/128,delta)        
        
        Lv1=[]
        for i in range(round((stop-start)/delta)):
            Lv1.append(start+delta*i)
        
        L=[line(l,delta,f) for l in Lv1]
        for l in L:
            l.calc()
    
        if adapt:
            for i in range(maxlevel-1):
                newL=[]
                for l in L:
                    l.split(newL)
                L=newL.copy()
                
        for l in L:
            l.findpoints()
                
        if plotbool:
            Px=[]
            for l in L:
                l.draw(plotaxis)
                for i in range(len(l.Px)):
                    matchbool=False
                    for j in range(len(Px)):
                        if abs(l.Px[i]-Px[j])<l.zero:
                            matchbool=True
                            break
                    if not matchbool:
                        Px.append(l.Px[i])
            if colormap is not None:
                try:
                    plotaxis.scatter(Px,[0 for px in Px],color=[colormap((px-start)/(stop-start)) for px in Px],alpha=alpha)
                except:
                    plotaxis.scatter(Px,[0 for px in Px],color=color,alpha=alpha)
            else:
                plotaxis.scatter(Px,[0 for px in Px],color=color,alpha=alpha)
                
            if plotshowbool:
                plt.show()
        else:
            Px=[]
            for l in L:
                for i in range(len(l.Px)):
                    matchbool=False
                    for j in range(len(Px)):
                        if abs(l.Px[i]-Px[j])<l.zero:
                            matchbool=True
                            break
                    if not matchbool:
                        Px.append(l.Px[i])
            return Px
    
    @staticmethod
    def plot2D(f,start,stop,delta,args=[],kwargs={},limit=[None,None],dependentvar="y",mode="cartesian",plotaxis=None,color="black",alpha=1.0):
        #This method provides a consistent way to plot any f:R->R function 
        #(cartesian or polar) between scalar lower bound start and scalar upper bound
        #stop, using delta as a step variable. The variable limit provides a 
        #lower and upper limit on the value of f. The variable dependentvar determines
        #which variable is a function of the other. For example, if the dependentvar
        #is y, then y(x)=f(x).
        plotshowbool=False
        if plotaxis is None:
            graphsize=9
            font = {"family": "serif",
                "color": "black",
                "weight": "bold",
                "size": "20"}
            plotfig=plt.figure(figsize=(graphsize,graphsize))
            if "pol" in mode.lower():
                plotaxis=plotfig.add_subplot(111,projection="polar")
            else:
                plotaxis=plotfig.add_subplot(111)
                plotaxis.set_xlabel("$\\mathbf{X}$",fontsize=16,rotation=0)
                plotaxis.set_ylabel("$\\mathbf{Y}$",fontsize=16,rotation=0)
            plotaxis.set_title("Function Graph",fontdict=font)
            plotaxis.xaxis.set_tick_params(labelsize=16)
            plotaxis.yaxis.set_tick_params(labelsize=16)
            plotshowbool=True
            
        Xgrid=np.linspace(start,stop,round((stop-start)/delta)+1)
        Ygrid=np.zeros(Xgrid.shape)
        
        for i in range(len(Xgrid)):
            try:
                res=f(Xgrid[i],*args,**kwargs)
            except ZeroDivisionError:
                neighbors=[]
                if i>0:
                    try:
                        neighbors.append(f(Xgrid[i-1],*args,**kwargs))
                    except:
                        pass
                if i<len(Xgrid)-1:
                    try:
                        neighbors.append(f(Xgrid[i+1],*args,**kwargs))
                    except:
                        pass
                if len(neighbors)>0:
                    res=sum(neighbors)/len(neighbors)
                else:
                    res=0
            Ygrid[i]=res
        
        if "x" in dependentvar.lower():
            plotaxis.plot(Ygrid,Xgrid,color=color,alpha=alpha)
        else:
            plotaxis.plot(Xgrid,Ygrid,color=color,alpha=alpha)
        if plotshowbool:
            plt.show()
                    
    @staticmethod
    def lineplot(f,start,stop,delta,args=[],kwargs={},adapt=True,maxlevel=5,mode="linear",plotbool=True,plotaxis=None,wireframe=True,colormap=None,color="black",alpha=1.0):
        #This method approximates the 1D solutions of f(x,y)=0, using the marching 
        #square algorithm. The zeros are found between lower bound vector start and 
        #upper bound vector stop, and divided into subsections of dimensions delta. 
        #The method can subdivide even further through variable adapt. The method 
        #then evenly bisects each subsection through each dimension and only focusses
        #on subsections that, as best as the method can tell, do not contain any 
        #solutions. The subsections then form a structure similar to a sparse 
        #quadtree. The maximum level of subdivisions is determined by variable
        #maxlevel. After subdivision, the zeros are approximated using either linear,
        #quadratic, or cubic interpolation, determined by variable mode. If plotted,
        #solutions are plotted either using a 2D wireframe (mostly just consisting
        #of straight lines) or by just plotting the point-cloud. A colormap option
        #is available to when plotting (colormap values are based on the y-coordinate).
        plotshowbool=False
        if plotbool and plotaxis is None:
            graphsize=9
            font = {"family": "serif",
                "color": "black",
                "weight": "bold",
                "size": "20"}
            plotfig=plt.figure(figsize=(graphsize,graphsize))
            plotaxis=plotfig.add_subplot(111)
            plotaxis.set_title("Function Line",fontdict=font)
            plotaxis.set_xlabel("$\\mathbf{X}$",fontsize=16,rotation=0)
            plotaxis.set_ylabel("$\\mathbf{Y}$",fontsize=16,rotation=0)
            plotaxis.xaxis.set_tick_params(labelsize=16)
            plotaxis.yaxis.set_tick_params(labelsize=16)
            plotshowbool=True
                
        paths=[[[]],
               [[2, 3]],
               [[1, 2]],
               [[1, 3]],
               [[0, 1]],
               [[0, 1], [2, 3]],
               [[0, 2]],
               [[0, 3]],
               [[0, 3]],
               [[0, 2]],
               [[0, 3], [1, 2]],
               [[0, 1]],
               [[1, 3]],
               [[1, 2]],
               [[2, 3]],
               [[]]]
        
        class square:
            def __init__(self,Sv1,deltax,deltay,f):
                if not isinstance(Sv1,np.ndarray):
                    Sv1=np.array(Sv1)
                self.deltax=deltax
                self.deltay=deltay
                self.V=[Sv1,Sv1+np.array([deltax,0]),Sv1+np.array([deltax,deltay]),Sv1+np.array([0,deltay])]
                self.c=0.5*(self.V[0]+self.V[2])
                self.errx=1e-3*(self.V[2][0]-self.V[0][0])
                self.erry=1e-3*(self.V[2][1]-self.V[0][1])
                self.zero=0.0#1e-6*self.deltax*self.deltay
                self.f=f
                self.F=[0 for i in range(4)]
                self.fc=0
                self.Px=[]
                self.Py=[]
                self.full=False
                self.done=False
                
            def adjust(self,a,fa,b=None):
                shift=100
                tempa=a
                tempfa=fa
                if math.isinf(fa) or math.isnan(fa):
                    i=1
                    if b is None:
                        b=0.5*(self.V[0]+self.V[2])
                    tempa=a+(b-a)/shift
                    tempfa=self.f(tempa,*args,**kwargs)
                    abool=math.isinf(tempfa) or math.isnan(fa)
                    while abool and i<shift-1:
                        i+=1
                        tempa=a+(b-a)*i/shift
                        tempfa=self.f(tempa,*args,**kwargs)
                        abool=math.isinf(tempfa) or math.isnan(fa)
                    if abool:
                        tempa=a
                        tempfa=fa
                return tempa,tempfa
            
            def intersect(self,a,b,fa,fb,Px,Py,mode="linear"):
                if mode.lower() in ["quad","quadratic","2","two","second"]:
                    if abs(a[0]-b[0])<=self.errx:
                        c=np.array([a[0],0.5*(a[1]+b[1])])
                        pivot=1
                    else:
                        c=np.array([0.5*(a[0]+b[0]),a[1]])
                        pivot=0
                    fc=self.f(c,*args,**kwargs)
                    c,fc=self.adjust(c,fc)
                    A=((b[pivot]-c[pivot])*fa+(c[pivot]-a[pivot])*fb+(a[pivot]-b[pivot])*fc)/((a[pivot]-b[pivot])*(a[pivot]-c[pivot])*(b[pivot]-c[pivot]))
                    B=((c[pivot]**2-b[pivot]**2)*fa+(a[pivot]**2-c[pivot]**2)*fb+(b[pivot]**2-a[pivot]**2)*fc)/((a[pivot]-b[pivot])*(a[pivot]-c[pivot])*(b[pivot]-c[pivot]))
                    C=((b[pivot]-c[pivot])*b[pivot]*c[pivot]*fa+(c[pivot]-a[pivot])*c[pivot]*a[pivot]*fb+(a[pivot]-b[pivot])*a[pivot]*b[pivot]*fc)/((a[pivot]-b[pivot])*(a[pivot]-c[pivot])*(b[pivot]-c[pivot]))
                    R=np.roots([A,B,C])
                    res=0
                    rcount=0
                    for r in R:
                        if abs(r.imag)<=self.zero:
                            if pivot==0:
                                err=self.errx
                            else:
                                err=self.erry
                            if abs(a[pivot]-r.real)<=err:
                                res+=a[pivot]
                                rcount+=1
                            elif abs(b[pivot]-r.real)<=err:
                                res+=b[pivot]
                                rcount+=1
                            else:
                                if a[pivot]<=b[pivot]:
                                    if a[pivot]<r.real<b[pivot]:
                                        res+=r.real
                                        rcount+=1
                                else:
                                    if a[pivot]>r.real>b[pivot]:
                                        res+=r.real
                                        rcount+=1
                    if rcount>0:
                        if pivot==0:
                            Px.append(res/rcount)
                            Py.append(a[1])
                        else:
                            Px.append(a[0])
                            Py.append(res/rcount)
                elif mode.lower() in ["cube","cubic","3","three","third"]:
                    if abs(a[0]-b[0])<=self.errx:
                        h=1e-3*self.deltay
                        aplus=a+np.array([0,h])
                        aminus=a-np.array([0,h])
                        bplus=b+np.array([0,h])
                        bminus=b-np.array([0,h])
                        pivot=1
                    else:
                        h=1e-3*self.deltax
                        aplus=a+np.array([h,0])
                        aminus=a-np.array([h,0])
                        bplus=b+np.array([h,0])
                        bminus=b-np.array([h,0])
                        pivot=0
                    
                    faplus=self.f(aplus,*args,**kwargs)
                    aplus,faplus=self.adjust(aplus,faplus)
                    faminus=self.f(aminus,*args,**kwargs)
                    aminus,faminus=self.adjust(aminus,faminus)
                    fbplus=self.f(bplus,*args,**kwargs)
                    bplus,fbplus=self.adjust(bplus,fbplus)            
                    fbminus=self.f(bminus,*args,**kwargs)
                    bminus,fbminus=self.adjust(bminus,fbminus)
                    
                    faprime=(faplus-faminus)/(2*h)
                    fbprime=(fbplus-fbminus)/(2*h)
                        
                    A=(a[pivot]*faprime+a[pivot]*fbprime-b[pivot]*faprime-b[pivot]*fbprime-2*fa+2*fb)/((a[pivot]-b[pivot])**3)
                    B=(-a[pivot]**2*faprime-2*a[pivot]**2*fbprime-a[pivot]*b[pivot]*faprime+a[pivot]*b[pivot]*fbprime+3*a[pivot]*fa-3*a[pivot]*fb+2*b[pivot]**2*faprime+b[pivot]**2*fbprime+3*b[pivot]*fa-3*b[pivot]*fb)/((a[pivot]-b[pivot])**3)
                    C=(a[pivot]**3*fbprime+2*a[pivot]**2*b[pivot]*faprime+a[pivot]**2*b[pivot]*fbprime-a[pivot]*b[pivot]**2*faprime-2*a[pivot]*b[pivot]**2*fbprime-6*a[pivot]*b[pivot]*fa+6*a[pivot]*b[pivot]*fb-b[pivot]**3*faprime)/((a[pivot]-b[pivot])**3)
                    D=(-a[pivot]**3*b[pivot]*fbprime+a[pivot]**3*fb-a[pivot]**2*b[pivot]**2*faprime+a[pivot]**2*b[pivot]**2*fbprime-3*a[pivot]**2*b[pivot]*fb+a[pivot]*b[pivot]**3*faprime+3*a[pivot]*b[pivot]**2*fa-b[pivot]**3*fa)/((a[pivot]-b[pivot])**3)
                    R=np.roots([A,B,C,D])
                    res=0
                    rcount=0
                    for r in R:
                        if abs(r.imag)<=self.zero:
                            if pivot==0:
                                err=self.errx
                            else:
                                err=self.erry
                            if abs(a[pivot]-r.real)<=err:
                                res+=a[pivot]
                                rcount+=1
                            elif abs(b[pivot]-r.real)<=err:
                                res+=b[pivot]
                                rcount+=1
                            else:
                                if a[pivot]<=b[pivot]:
                                    if a[pivot]<r.real<b[pivot]:
                                        res+=r.real
                                        rcount+=1
                                else:
                                    if a[pivot]>r.real>b[pivot]:
                                        res+=r.real
                                        rcount+=1
                    if rcount>0:
                        if pivot==0:
                            Px.append(res/rcount)
                            Py.append(a[1])
                        elif pivot==1:
                            Px.append(a[0])
                            Py.append(res/rcount)
                else:
                    temp=(a*fb-b*fa)/(fb-fa)
                    Px.append(temp[0])
                    Py.append(temp[1])
            
            def calc(self):
                for i in range(4):
                    v,fv=self.adjust(self.V[i],self.f(self.V[i],*args,**kwargs))
                    self.F[i]=fv
                self.c,self.fc=self.adjust(self.c,self.f(self.c,*args,**kwargs),b=self.V[0])
                self.full=True
                for fv in self.F:
                    if abs(fv)>self.zero:
                        self.full=False
                        break
                
                if not self.full:
                    if all([fv<0 for fv in self.F]) or all([fv>0 for fv in self.F]):
                        self.done=True
                        for i in range(4):
                            if i<3:
                                mid=0.5*(self.V[i]+self.V[i+1])
                            else:
                                mid=0.5*(self.V[0]+self.V[3])
                            mid,fm=self.adjust(mid,self.f(mid,*args,**kwargs))
                            if fm*self.fc<0:
                                self.done=False
                                break        
                    
            def split(self,S):
                if not self.done and not self.full:
                    splitS=[]
                    for s in [square(0.5*(self.V[0]+self.V[i]),self.deltax/2,self.deltay/2,f) for i in range(4)]:
                        s.calc()
                        if not s.done:
                            splitS.append(s)
                    S+=splitS
                elif self.full:
                    S+=[self]
            
            def findpoints(self):
                if not self.done and not self.full:
                    index=0
                    for i in range(4):
                        if self.F[i]<=self.zero:
                            index+=2**(3-i)
                    if index==5:
                        if self.fc<=self.zero:
                            index==10
                    elif index==10:
                        if self.fc<=self.zero:
                            index==5
                    path=paths[index]
                    for p in path:
                        if len(p)>1:
                            for e in p:
                                if 0<=e<=2:
                                    self.intersect(self.V[e],self.V[e+1],self.F[e],self.F[e+1],self.Px,self.Py,mode=mode)
                                else:
                                    self.intersect(self.V[3],self.V[0],self.F[3],self.F[0],self.Px,self.Py,mode=mode)                
            
            def draw(self,plotaxis):
                if not self.done:
                    if self.full:
                        if colormap is not None:
                            try:
                                plotaxis.plot([self.V[i][0] for i in range(4)]+[self.V[0][0]],[self.V[i][1] for i in range(4)]+[self.V[0][1]],color=colormap((0.5*(self.V[0][1]+self.V[2][1])-start[1])/(stop[1]-start[1])),alpha=alpha)
                            except:
                                plotaxis.plot([self.V[i][0] for i in range(4)]+[self.V[0][0]],[self.V[i][1] for i in range(4)]+[self.V[0][1]],color=color,alpha=alpha)
                        else:
                            plotaxis.plot([self.V[i][0] for i in range(4)]+[self.V[0][0]],[self.V[i][1] for i in range(4)]+[self.V[0][1]],color=color,alpha=alpha)
                    else:
                        if len(self.Px)>0 and len(self.Px)==len(self.Py):
                            if colormap is not None:
                                try:
                                    plotaxis.plot(self.Px,self.Py,color=colormap((sum(self.Py)/len(self.Py)-start[1])/(stop[1]-start[1])),alpha=alpha)
                                except:
                                    plotaxis.plot(self.Px,self.Py,color=color,alpha=alpha)
                            else:
                                plotaxis.plot(self.Px,self.Py,color=color,alpha=alpha)
                            
        if adapt:
            delta=[max((stop[i]-start[i])/10,delta[i]) for i in range(2)]
        else:
            delta=[max((stop[i]-start[i])/128,delta[i]) for i in range(2)]        
        
        Sv1=[]
        for i in range(round((stop[0]-start[0])/delta[0])):
            for j in range(round((stop[1]-start[1])/delta[1])):
                Sv1.append(np.array([start[0]+delta[0]*i,start[1]+delta[1]*j]))
        
        S=[square(s,delta[0],delta[1],f) for s in Sv1]
        for s in S:
            s.calc()
    
        if adapt:
            for i in range(maxlevel-1):
                newS=[]
                for s in S:
                    s.split(newS)
                S=[s for s in newS]
        
        for s in S:
            s.findpoints()
            
        if plotbool:
            if wireframe:
                for s in S:
                    s.draw(plotaxis)
            else:
                Px,Py=[],[]
                for s in S:
                    for i in range(len(s.Px)):
                        matchbool=False
                        for j in range(len(Px)):
                            if abs(s.Px[i]-Px[j])<=s.zero and abs(s.Py[i]-Py[j])<=s.zero:
                                matchbool=True
                                break
                        if not matchbool:
                            Px.append(s.Px[i])
                            Py.append(s.Py[i])
                if colormap is not None:
                    try:
                        plotaxis.scatter(Px,Py,color=[colormap((py-start[1])/(stop[1]-start[1])) for py in Py],alpha=alpha)
                    except:
                        plotaxis.scatter(Px,Py,color=color,alpha=alpha)
                else:
                    plotaxis.scatter(Px,Py,color=color,alpha=alpha)
            if plotshowbool:
                plt.show()
        else:
            Px,Py=[],[]
            for s in S:
                for i in range(len(s.Px)):
                    matchbool=False
                    for j in range(len(Px)):
                        if abs(s.Px[i]-Px[j])<=s.zero and abs(s.Py[i]-Py[j])<=s.zero:
                            matchbool=True
                            break
                    if not matchbool:
                        Px.append(s.Px[i])
                        Py.append(s.Py[i])
            return Px,Py
            
    @staticmethod
    def plot3D(f,start,stop,delta,args=[],kwargs={},limit=[None,None],dependentvar="z",plotaxis=None,wireframe=False,colormap=None,color="black",alpha=1.0):
        #This method provides a consistent way to plot any f:R^2->R function 
        #between lower bound vector start and upper bound vector stop, using delta 
        #as a step vector. The variable limit provides a lower and upper limit on 
        #the value of f. The method either returns the entire surface of the graph 
        #when the variable wireframe is False, or returns just the wireframe when 
        #the variable wireframe is True. The variable dependentvar determines which
        #variable is a function of the other. For example, if the dependentvar is y,
        #then y(x,z)=f(x,z). A colormap option is available to when plotting 
        #(colormap values are based on the dependentvar-coordinate), but only when 
        #the varaiable wireframe is False.
        plotshowbool=False
        if plotaxis is None:
            graphsize=9
            font = {"family": "serif",
                "color": "black",
                "weight": "bold",
                "size": "20"}
            plotaxis=Axes3D(plt.figure(figsize=(graphsize,graphsize)))
            plotaxis.set_title("Function Surface",fontdict=font)
            plotaxis.xaxis.set_rotate_label(False)
            plotaxis.set_xlabel("$\\mathbf{X}$",fontsize=16,rotation=0)
            plotaxis.yaxis.set_rotate_label(False)
            plotaxis.set_ylabel("$\\mathbf{Y}$",fontsize=16,rotation=0)
            plotaxis.zaxis.set_rotate_label(False)
            plotaxis.set_zlabel("$\\mathbf{Z}$",fontsize=16,rotation=0)
            plotaxis.xaxis.set_tick_params(labelsize=16)
            plotaxis.yaxis.set_tick_params(labelsize=16)
            plotaxis.zaxis.set_tick_params(labelsize=16)
            plotshowbool=True
        
        x=np.linspace(start[0],stop[0],round((stop[0]-start[0])/delta[0])+1)
        y=np.linspace(start[1],stop[1],round((stop[1]-start[1])/delta[1])+1)
        Xgrid,Ygrid=np.meshgrid(x,y)
        Zgrid=np.zeros(Xgrid.shape)
        
        if isinstance(limit[0],int) or isinstance(limit[0],float):
            lowerlimitbool=True
        else:
            lowerlimitbool=False
        if isinstance(limit[1],int) or isinstance(limit[1],float):
            upperlimitbool=True
        else:
            upperlimitbool=False
        
        for i in range(len(y)):
            for j in range(len(x)):
                try:
                    res=f(x[j],y[i],*args,**kwargs)
                except ZeroDivisionError:
                    neighbors=[]
                    if i>0:
                        try:
                            neighbors.append(f(x[j],y[i-1],*args,**kwargs))
                        except:
                            pass
                    if i<len(y)-1:
                        try:
                            neighbors.append(f(x[j],y[i+1],*args,**kwargs))
                        except:
                            pass
                    if j>0:
                        try:
                            neighbors.append(f(x[j-1],y[i],*args,**kwargs))
                        except:
                            pass
                    if j<len(x)-1:
                        try:
                            neighbors.append(f(x[j+1],y[i],*args,**kwargs))
                        except:
                            pass
                    if len(neighbors)>0:
                        res=sum(neighbors)/len(neighbors)
                    else:
                        res=0
                if lowerlimitbool and res<limit[0]:
                    res=limit[0]
                if upperlimitbool and res>limit[1]:
                    res=limit[1]
                Zgrid[i][j]=res
                
        if wireframe:
            if "x" in dependentvar.lower():
                plotaxis.plot_wireframe(Zgrid,Xgrid,Ygrid,color=color,alpha=alpha)
            elif "y" in dependentvar.lower():
                plotaxis.plot_wireframe(Xgrid,Zgrid,Ygrid,color=color,alpha=alpha)
            else:
                plotaxis.plot_wireframe(Xgrid,Ygrid,Zgrid,color=color,alpha=alpha)
        else:
            if colormap is not None:
                if "x" in dependentvar.lower():
                    plotaxis.plot_surface(Zgrid,Xgrid,Ygrid,cmap=colormap,alpha=alpha)
                elif "y" in dependentvar.lower():
                    plotaxis.plot_surface(Xgrid,Zgrid,Ygrid,cmap=colormap,alpha=alpha)
                else:
                    plotaxis.plot_surface(Xgrid,Ygrid,Zgrid,cmap=colormap,alpha=alpha)
            else:
                if "x" in dependentvar.lower():
                    plotaxis.plot_surface(Zgrid,Xgrid,Ygrid,color=color,alpha=alpha)
                elif "y" in dependentvar.lower():
                    plotaxis.plot_surface(Xgrid,Zgrid,Ygrid,color=color,alpha=alpha)
                else:
                    plotaxis.plot_surface(Xgrid,Ygrid,Zgrid,color=color,alpha=alpha)
        if plotshowbool:
            plt.show()
    
    @staticmethod
    def surfaceplot(f,start,stop,delta,args=[],kwargs={},adapt=True,maxlevel=3,mode="linear",plotbool=True,plotaxis=None,wireframe=True,surface=False,colormap=None,color="black",alpha=1.0):
        #This method approximates the 2D solutions of f(x,y,z)=0, using the marching 
        #cube algorithm. The zeros are found between lower bound vector start and 
        #upper bound vector stop, and divided into subsections of dimensions delta. 
        #The method can subdivide even further through variable adapt. The method 
        #then evenly bisects each subsection through each dimension and only focusses
        #on subsections that, as best as the method can tell, do not contain any 
        #solutions. The subsections then form a structure similar to a sparse 
        #octree. The maximum level of subdivisions is determined by variable
        #maxlevel. After subdivision, the zeros are approximated using either linear,
        #quadratic, or cubic interpolation, determined by variable mode. If plotted,
        #solutions are plotted either using a wireframe (when variable wireframe is
        #True), a polygonal surface reconstruction (when the variable surface is True),
        #or by just plotting the point-cloud (when both wireframe and surface are 
        #False). A colormap option is available to when plotting (colormap values 
        #are based on the z-coordinate).
        plotshowbool=False
        if plotbool and plotaxis is None:
            graphsize=9
            font = {"family": "serif",
                "color": "black",
                "weight": "bold",
                "size": "20"}
            plotfig=plt.figure(figsize=(graphsize,graphsize))
            plotaxis=Axes3D(plotfig)
            plotaxis.set_title("Function Surface",fontdict=font)
            plotaxis.xaxis.set_rotate_label(False)
            plotaxis.set_xlabel("$\\mathbf{X}$",fontsize=16,rotation=0)
            plotaxis.yaxis.set_rotate_label(False)
            plotaxis.set_ylabel("$\\mathbf{Y}$",fontsize=16,rotation=0)
            plotaxis.zaxis.set_rotate_label(False)
            plotaxis.set_zlabel("$\\mathbf{Z}$",fontsize=16,rotation=0)
            plotaxis.xaxis.set_tick_params(labelsize=16)
            plotaxis.yaxis.set_tick_params(labelsize=16)
            plotaxis.zaxis.set_tick_params(labelsize=16)
            plotshowbool=True
        
        xlim=plotaxis.get_xlim()
        ylim=plotaxis.get_ylim()
        zlim=plotaxis.get_zlim()
        if xlim!=(0.0,1.0):
            plotaxis.set_xlim([min(xlim[0],start[0]),max(xlim[1],stop[0])])
        else:
            plotaxis.set_xlim([start[0],stop[0]])
        if ylim!=(0.0,1.0):
            plotaxis.set_ylim([min(ylim[0],start[1]),max(ylim[1],stop[1])])
        else:
            plotaxis.set_ylim([start[1],stop[1]])
        if zlim!=(0.0,1.0):
            plotaxis.set_zlim([min(zlim[0],start[2]),max(zlim[1],stop[2])])
        else:
            plotaxis.set_zlim([start[2],stop[2]])
            
        phi=plotaxis.azim*math.pi/180
        theta=(90-plotaxis.elev)*math.pi/180
        viewWeights=[math.sin(theta)*math.cos(phi),math.sin(theta)*math.sin(phi),math.cos(theta)]
        
        paths=[[[]],
                [[6,7,11,6]],
                [[5,6,10,5]],
                [[5,7,11,10,5]],
                [[4,5,9,4]],
                [[4,5,9,4],[6,7,11,6]],
                [[4,6,10,9,4]],
                [[4,7,11,10,9,4]],
                [[4,7,8,4]],
                [[4,6,11,8,4]],
                [[4,7,8,4],[5,6,10,5]],
                [[4,5,10,11,8,4]],
                [[5,7,8,9,5]],
                [[5,6,11,8,9,5]],
                [[6,7,8,9,10,6]],
                [[8,9,10,11,8]],
                [[2,3,11,2]],
                [[2,3,7,6,2]],
                [[2,3,11,2],[5,6,10,5]],
                [[2,3,7,5,10,2]],
                [[2,3,11,2],[4,5,9,4]],
                [[2,3,7,6,2],[4,5,9,4]],
                [[2,3,11,2],[4,6,10,9,4]],
                [[2,3,7,4,9,10,2]],
                [[2,3,11,2],[4,7,8,4]],
                [[2,3,8,4,6,2]],
                [[2,3,11,2],[4,7,8,4],[5,6,10,5]],
                [[2,3,8,4,5,10,2]],
                [[2,3,11,2],[5,7,8,9,5]],
                [[2,3,8,9,5,6,2]],
                [[2,3,11,2],[6,7,8,9,10,6]],
                [[2,3,8,9,10,2]],
                [[1,2,10,1]],
                [[1,2,10,1],[6,7,11,6]],
                [[1,2,6,5,1]],
                [[1,2,11,7,5,1]],
                [[1,2,10,1],[4,5,9,4]],
                [[1,2,10,1],[4,5,9,4],[6,7,11,6]],
                [[1,2,6,4,9,1]],
                [[1,2,11,7,4,9,1]],
                [[1,2,10,1],[4,7,8,4]],
                [[1,2,10,1],[4,6,11,8,4]],
                [[1,2,6,5,1],[4,7,8,4]],
                [[1,2,11,8,4,5,1]],
                [[1,2,10,1],[5,7,8,9,5]],
                [[1,2,10,1],[5,6,11,8,9,5]],
                [[1,2,6,7,8,9,1]],
                [[1,2,11,8,9,1]],
                [[1,3,11,10,1]],
                [[1,3,7,6,10,1]],
                [[1,3,11,6,5,1]],
                [[1,3,7,5,1]],
                [[1,3,11,10,1],[4,5,9,4]],
                [[1,3,7,6,10,1],[4,5,9,4]],
                [[1,3,11,6,4,9,1]],
                [[1,3,7,4,9,1]],
                [[1,3,11,10,1],[4,7,8,4]],
                [[1,3,8,4,6,10,1]],
                [[1,3,11,6,5,1],[4,7,8,4]],
                [[1,3,8,4,5,1]],
                [[1,3,11,10,1],[5,7,8,9,5]],
                [[1,3,8,9,1],[5,6,10,5]],
                [[1,3,8,9,1],[6,7,11,6]],
                [[1,3,8,9,1]],
                [[0,1,9,0]],
                [[0,1,9,0],[6,7,11,6]],
                [[0,1,9,0],[5,6,10,5]],
                [[0,1,9,0],[5,7,11,10,5]],
                [[0,1,5,4,0]],
                [[0,1,5,4,0],[6,7,11,6]],
                [[0,1,10,6,4,0]],
                [[0,1,10,11,7,4,0]],
                [[0,1,9,0],[4,7,8,4]],
                [[0,1,9,0],[4,6,11,8,4]],
                [[0,1,9,0],[4,7,8,4],[5,6,10,5]],
                [[0,1,9,0],[4,5,10,11,8,4]],
                [[0,1,5,7,8,0]],
                [[0,1,5,6,11,8,0]],
                [[0,1,10,6,7,8,0]],
                [[0,1,10,11,8,0]],
                [[0,1,9,0],[2,3,11,2]],
                [[0,1,9,0],[2,3,7,6,2]],
                [[0,1,9,0],[2,3,11,2],[5,6,10,5]],
                [[0,1,9,0],[2,3,7,5,10,2]],
                [[0,1,5,4,0],[2,3,11,2]],
                [[0,1,5,4,0],[2,3,7,6,2]],
                [[0,1,10,6,4,0],[2,3,11,2]],
                [[0,3,7,4,0],[1,2,10,1]],
                [[0,1,9,0],[2,3,11,2],[4,7,8,4]],
                [[0,1,9,0],[2,3,8,4,6,2]],
                [[0,1,9,0],[2,3,11,2],[4,7,8,4],[5,6,10,5]],
                [[0,1,9,0],[2,3,8,4,5,10,2]],
                [[0,1,5,7,8,0],[2,3,11,2]],
                [[0,3,8,0],[1,2,6,5,1]],
                [[0,3,8,0],[1,2,10,1],[6,7,11,6]],
                [[0,3,8,0],[1,2,10,1]],
                [[0,2,10,9,0]],
                [[0,2,10,9,0],[6,7,11,6]],
                [[0,2,6,5,9,0]],
                [[0,2,11,7,5,9,0]],
                [[0,2,10,5,4,0]],
                [[0,2,11,7,4,0],[5,6,10,5]],
                [[0,2,6,4,0]],
                [[0,2,11,7,4,0]],
                [[0,2,10,9,0],[4,7,8,4]],
                [[0,2,10,9,0],[4,6,11,8,4]],
                [[0,2,6,5,9,0],[4,7,8,4]],
                [[0,2,11,8,0],[4,5,9,4]],
                [[0,2,10,5,7,8,0]],
                [[0,2,11,8,0],[5,6,10,5]],
                [[0,2,6,7,8,0]],
                [[0,2,11,8,0]],
                [[0,3,11,10,9,0]],
                [[0,3,7,6,10,9,0]],
                [[0,3,11,6,5,9,0]],
                [[0,3,7,5,9,0]],
                [[0,3,11,10,5,4,0]],
                [[0,3,7,4,0],[5,6,10,5]],
                [[0,3,11,6,4,0]],
                [[0,3,7,4,0]],
                [[0,3,11,10,9,0],[4,7,8,4]],
                [[0,3,8,0],[4,6,10,9,4]],
                [[0,3,8,0],[4,5,9,4],[6,7,11,6]],
                [[0,3,8,0],[4,5,9,4]],
                [[0,3,8,0],[5,7,11,10,5]],
                [[0,3,8,0],[5,6,10,5]],
                [[0,3,8,0],[6,7,11,6]],
                [[0,3,8,0]],
                [[0,3,8,0]],
                [[0,3,8,0],[6,7,11,6]],
                [[0,3,8,0],[5,6,10,5]],
                [[0,3,8,0],[5,7,11,10,5]],
                [[0,3,8,0],[4,5,9,4]],
                [[0,3,8,0],[4,5,9,4],[6,7,11,6]],
                [[0,3,8,0],[4,6,10,9,4]],
                [[0,3,8,0],[4,7,11,10,9,4]],
                [[0,3,7,4,0]],
                [[0,3,11,6,4,0]],
                [[0,3,7,4,0],[5,6,10,5]],
                [[0,3,11,10,5,4,0]],
                [[0,3,7,5,9,0]],
                [[0,3,11,6,5,9,0]],
                [[0,3,7,6,10,9,0]],
                [[0,3,11,10,9,0]],
                [[0,2,11,8,0]],
                [[0,2,6,7,8,0]],
                [[0,2,11,8,0],[5,6,10,5]],
                [[0,2,10,5,7,8,0]],
                [[0,2,11,8,0],[4,5,9,4]],
                [[0,2,6,7,8,0],[4,5,9,4]],
                [[0,2,11,8,0],[4,6,10,9,4]],
                [[0,2,10,9,0],[4,7,8,4]],
                [[0,2,11,7,4,0]],
                [[0,2,6,4,0]],
                [[0,2,11,7,4,0],[5,6,10,5]],
                [[0,2,10,5,4,0]],
                [[0,2,11,7,5,9,0]],
                [[0,2,6,5,9,0]],
                [[0,2,10,9,0],[6,7,11,6]],
                [[0,2,10,9,0]],
                [[0,3,8,0],[1,2,10,1]],
                [[0,3,8,0],[1,2,10,1],[6,7,11,6]],
                [[0,3,8,0],[1,2,6,5,1]],
                [[0,3,8,0],[1,2,11,7,5,1]],
                [[0,3,8,0],[1,2,10,1],[4,5,9,4]],
                [[0,3,8,0],[1,2,10,1],[4,5,9,4],[6,7,11,6]],
                [[0,3,8,0],[1,2,6,4,9,1]],
                [[0,3,8,0],[1,2,11,7,4,9,1]],
                [[0,3,7,4,0],[1,2,10,1]],
                [[0,3,11,6,4,0],[1,2,10,1]],
                [[0,3,7,4,0],[1,2,6,5,1]],
                [[0,1,5,4,0],[2,3,11,2]],
                [[0,1,9,0],[2,3,7,5,10,2]],
                [[0,1,9,0],[2,3,11,2],[5,6,10,5]],
                [[0,1,9,0],[2,3,7,6,2]],
                [[0,1,9,0],[2,3,11,2]],
                [[0,1,10,11,8,0]],
                [[0,1,10,6,7,8,0]],
                [[0,1,5,6,11,8,0]],
                [[0,1,5,7,8,0]],
                [[0,1,9,0],[4,5,10,11,8,4]],
                [[0,1,9,0],[4,7,8,4],[5,6,10,5]],
                [[0,1,9,0],[4,6,11,8,4]],
                [[0,1,9,0],[4,7,8,4]],
                [[0,1,10,11,7,4,0]],
                [[0,1,10,6,4,0]],
                [[0,1,5,4,0],[6,7,11,6]],
                [[0,1,5,4,0]],
                [[0,1,9,0],[5,7,11,10,5]],
                [[0,1,9,0],[5,6,10,5]],
                [[0,1,9,0],[6,7,11,6]],
                [[0,1,9,0]],
                [[1,3,8,9,1]],
                [[1,3,8,9,1],[6,7,11,6]],
                [[1,3,8,9,1],[5,6,10,5]],
                [[1,3,8,9,1],[5,7,11,10,5]],
                [[1,3,8,4,5,1]],
                [[1,3,8,4,5,1],[6,7,11,6]],
                [[1,3,8,4,6,10,1]],
                [[1,3,11,10,1],[4,7,8,4]],
                [[1,3,7,4,9,1]],
                [[1,3,11,6,4,9,1]],
                [[1,3,7,6,10,1],[4,5,9,4]],
                [[1,3,11,10,1],[4,5,9,4]],
                [[1,3,7,5,1]],
                [[1,3,11,6,5,1]],
                [[1,3,7,6,10,1]],
                [[1,3,11,10,1]],
                [[1,2,11,8,9,1]],
                [[1,2,6,7,8,9,1]],
                [[1,2,11,8,9,1],[5,6,10,5]],
                [[1,2,10,1],[5,7,8,9,5]],
                [[1,2,11,8,4,5,1]],
                [[1,2,6,5,1],[4,7,8,4]],
                [[1,2,10,1],[4,6,11,8,4]],
                [[1,2,10,1],[4,7,8,4]],
                [[1,2,11,7,4,9,1]],
                [[1,2,6,4,9,1]],
                [[1,2,11,7,4,9,1],[5,6,10,5]],
                [[1,2,10,1],[4,5,9,4]],
                [[1,2,11,7,5,1]],
                [[1,2,6,5,1]],
                [[1,2,10,1],[6,7,11,6]],
                [[1,2,10,1]],
                [[2,3,8,9,10,2]],
                [[2,3,11,2],[6,7,8,9,10,6]],
                [[2,3,8,9,5,6,2]],
                [[2,3,11,2],[5,7,8,9,5]],
                [[2,3,8,4,5,10,2]],
                [[2,3,11,2],[4,7,8,4],[5,6,10,5]],
                [[2,3,8,4,6,2]],
                [[2,3,11,2],[4,7,8,4]],
                [[2,3,7,4,9,10,2]],
                [[2,3,11,2],[4,6,10,9,4]],
                [[2,3,7,6,2],[4,5,9,4]],
                [[2,3,11,2],[4,5,9,4]],
                [[2,3,7,5,10,2]],
                [[2,3,11,2],[5,6,10,5]],
                [[2,3,7,6,2]],
                [[2,3,11,2]],
                [[8,9,10,11,8]],
                [[6,7,8,9,10,6]],
                [[5,6,11,8,9,5]],
                [[5,7,8,9,5]],
                [[4,5,10,11,8,4]],
                [[4,7,8,4],[5,6,10,5]],
                [[4,6,11,8,4]],
                [[4,7,8,4]],
                [[4,7,11,10,9,4]],
                [[4,6,10,9,4]],
                [[4,5,9,4],[6,7,11,6]],
                [[4,5,9,4]],
                [[5,7,11,10,5]],
                [[5,6,10,5]],
                [[6,7,11,6]],
                [[]]]
        
        class cube:
            def __init__(self,Sv1,deltax,deltay,deltaz,f):
                if not isinstance(Sv1,np.ndarray):
                    Sv1=np.array(Sv1)
                self.deltax=deltax
                self.deltay=deltay
                self.deltaz=deltaz
                self.V=[Sv1,Sv1+np.array([deltax,0,0]),Sv1+np.array([deltax,deltay,0]),Sv1+np.array([0,deltay,0]),Sv1+np.array([0,0,deltaz]),Sv1+np.array([deltax,0,deltaz]),Sv1+np.array([deltax,deltay,deltaz]),Sv1+np.array([0,deltay,deltaz])]
                self.viewVal=sum([(self.V[0][i]-start[i]+self.V[6][i]-stop[i])/2*viewWeights[i] for i in range(3)])
                self.errx=1e-3*(self.V[6][0]-self.V[0][0])
                self.erry=1e-3*(self.V[6][1]-self.V[0][1])
                self.errz=1e-3*(self.V[6][2]-self.V[0][2])
                self.zero=0.0#1e-6*self.deltax*self.deltay*self.deltaz
                self.f=f
                self.F=[0 for i in range(8)]
                self.full=False
                self.done=False
                self.Px=[]
                self.Py=[]
                self.Pz=[]
                
            def adjust(self,a,fa,b=None):
                shift=100
                tempa=a
                tempfa=fa
                if math.isinf(fa) or math.isnan(fa):
                    i=1
                    if b is None:
                        b=0.5*(self.V[0]+self.V[6])
                    tempa=a+(b-a)/shift
                    tempfa=self.f(tempa,*args,**kwargs)
                    abool=math.isinf(tempfa) or math.isnan(fa)
                    while abool and i<shift-1:
                        i+=1
                        tempa=a+(b-a)*i/shift
                        tempfa=self.f(tempa,*args,**kwargs)
                        abool=math.isinf(tempfa) or math.isnan(fa)
                    if abool:
                        tempa=a
                        tempfa=fa
                return tempa,tempfa
            
            def intersect(self,a,b,fa,fb,Px,Py,Pz,mode="linear"):
                if mode.lower() in ["quad","quadratic","2","two","second"]:
                    if abs(a[0]-b[0])<=self.errx and abs(a[1]-b[1])<=self.erry:
                        c=np.array([a[0],a[1],0.5*(a[2]+b[2])])
                        pivot=2
                    elif abs(a[0]-b[0])<=self.erry and abs(a[2]-b[2])<=self.errz:
                        c=np.array([a[0],0.5*(a[1]+b[1]),a[2]])
                        pivot=1
                    else:
                        c=np.array([0.5*(a[0]+b[0]),a[1],a[2]])
                        pivot=0
                    fc=self.f(c,*args,**kwargs)
                    c,fc=self.adjust(c,fc)
                    A=((b[pivot]-c[pivot])*fa+(c[pivot]-a[pivot])*fb+(a[pivot]-b[pivot])*fc)/((a[pivot]-b[pivot])*(a[pivot]-c[pivot])*(b[pivot]-c[pivot]))
                    B=((c[pivot]**2-b[pivot]**2)*fa+(a[pivot]**2-c[pivot]**2)*fb+(b[pivot]**2-a[pivot]**2)*fc)/((a[pivot]-b[pivot])*(a[pivot]-c[pivot])*(b[pivot]-c[pivot]))
                    C=((b[pivot]-c[pivot])*b[pivot]*c[pivot]*fa+(c[pivot]-a[pivot])*c[pivot]*a[pivot]*fb+(a[pivot]-b[pivot])*a[pivot]*b[pivot]*fc)/((a[pivot]-b[pivot])*(a[pivot]-c[pivot])*(b[pivot]-c[pivot]))
                    R=np.roots([A,B,C])
                    res=0
                    rcount=0
                    for r in R:
                        if abs(r.imag)<=self.zero:
                            if pivot==0:
                                err=self.errx
                            elif pivot==1:
                                err=self.erry
                            else:
                                err=self.errz
                            if abs(a[pivot]-r.real)<=err:
                                res+=a[pivot]
                                rcount+=1
                            elif abs(b[pivot]-r.real)<=err:
                                res+=b[pivot]
                                rcount+=1
                            else:
                                if a[pivot]<=b[pivot]:
                                    if a[pivot]<r.real<b[pivot]:
                                        res+=r.real
                                        rcount+=1
                                else:
                                    if a[pivot]>r.real>b[pivot]:
                                        res+=r.real
                                        rcount+=1
                    if rcount>0:
                        if pivot==0:
                            Px.append(res/rcount)
                            Py.append(a[1])
                            Pz.append(a[2])
                        elif pivot==1:
                            Px.append(a[0])
                            Py.append(res/rcount)
                            Pz.append(a[2])
                        else:
                            Px.append(a[0])
                            Py.append(a[1])
                            Pz.append(res/rcount)
                elif mode.lower() in ["cube","cubic","3","three","third"]:
                    if abs(a[0]-b[0])<=self.errx and abs(a[1]-b[1])<=self.erry:
                        h=1e-3*self.deltaz
                        aplus=a+np.array([0,0,h])
                        aminus=a-np.array([0,0,h])
                        bplus=b+np.array([0,0,h])
                        bminus=b-np.array([0,0,h])
                        pivot=2
                    elif abs(a[0]-b[0])<=self.errx and abs(a[2]-b[2])<=self.errz:
                        h=1e-3*self.deltay
                        aplus=a+np.array([0,h,0])
                        aminus=a-np.array([0,h,0])
                        bplus=b+np.array([0,h,0])
                        bminus=b-np.array([0,h,0])
                        pivot=1
                    else:
                        h=1e-3*self.deltax
                        aplus=a+np.array([h,0,0])
                        aminus=a-np.array([h,0,0])
                        bplus=b+np.array([h,0,0])
                        bminus=b-np.array([h,0,0])
                        pivot=0
                    
                    faplus=self.f(aplus,*args,**kwargs)
                    aplus,faplus=self.adjust(aplus,faplus)
                    faminus=self.f(aminus,*args,**kwargs)
                    aminus,faminus=self.adjust(aminus,faminus)
                    fbplus=self.f(bplus,*args,**kwargs)
                    bplus,fbplus=self.adjust(bplus,fbplus)            
                    fbminus=self.f(bminus,*args,**kwargs)
                    bminus,fbminus=self.adjust(bminus,fbminus)
                    
                    faprime=(faplus-faminus)/(2*h)
                    fbprime=(fbplus-fbminus)/(2*h)
                        
                    A=(a[pivot]*faprime+a[pivot]*fbprime-b[pivot]*faprime-b[pivot]*fbprime-2*fa+2*fb)/((a[pivot]-b[pivot])**3)
                    B=(-a[pivot]**2*faprime-2*a[pivot]**2*fbprime-a[pivot]*b[pivot]*faprime+a[pivot]*b[pivot]*fbprime+3*a[pivot]*fa-3*a[pivot]*fb+2*b[pivot]**2*faprime+b[pivot]**2*fbprime+3*b[pivot]*fa-3*b[pivot]*fb)/((a[pivot]-b[pivot])**3)
                    C=(a[pivot]**3*fbprime+2*a[pivot]**2*b[pivot]*faprime+a[pivot]**2*b[pivot]*fbprime-a[pivot]*b[pivot]**2*faprime-2*a[pivot]*b[pivot]**2*fbprime-6*a[pivot]*b[pivot]*fa+6*a[pivot]*b[pivot]*fb-b[pivot]**3*faprime)/((a[pivot]-b[pivot])**3)
                    D=(-a[pivot]**3*b[pivot]*fbprime+a[pivot]**3*fb-a[pivot]**2*b[pivot]**2*faprime+a[pivot]**2*b[pivot]**2*fbprime-3*a[pivot]**2*b[pivot]*fb+a[pivot]*b[pivot]**3*faprime+3*a[pivot]*b[pivot]**2*fa-b[pivot]**3*fa)/((a[pivot]-b[pivot])**3)
                    R=np.roots([A,B,C,D])
                    res=0
                    rcount=0
                    for r in R:
                        if abs(r.imag)<=self.zero:
                            if pivot==0:
                                err=self.errx
                            elif pivot==1:
                                err=self.erry
                            else:
                                err=self.errz
                            if abs(a[pivot]-r.real)<=err:
                                res+=a[pivot]
                                rcount+=1
                            elif abs(b[pivot]-r.real)<=err:
                                res+=b[pivot]
                                rcount+=1
                            else:
                                if a[pivot]<=b[pivot]:
                                    if a[pivot]<r.real<b[pivot]:
                                        res+=r.real
                                        rcount+=1
                                else:
                                    if a[pivot]>r.real>b[pivot]:
                                        res+=r.real
                                        rcount+=1
                    if rcount>0:
                        if pivot==0:
                            Px.append(res/rcount)
                            Py.append(a[1])
                            Pz.append(a[2])
                        elif pivot==1:
                            Px.append(a[0])
                            Py.append(res/rcount)
                            Pz.append(a[2])
                        else:
                            Px.append(a[0])
                            Py.append(a[1])
                            Pz.append(res/rcount)
                else:
                    temp=(a*fb-b*fa)/(fb-fa)
                    Px.append(temp[0])
                    Py.append(temp[1])
                    Pz.append(temp[2])
            
            def calc(self):
                for i in range(8):
                    v,fv=self.adjust(self.V[i],self.f(self.V[i],*args,**kwargs))
                    self.F[i]=fv
                self.full=True
                for fv in self.F:
                    if abs(fv)>self.zero:
                        self.full=False
                        break
                
                if not self.full:
                    if all([fv<0 for fv in self.F]) or all([fv>0 for fv in self.F]):
                        self.done=True
                        c,fc=self.adjust(0.5*(self.V[0]+self.V[6]),self.f(0.5*(self.V[0]+self.V[6]),*args,**kwargs),b=self.V[0])
                        for i in range(6):
                            if i in [0,1,2]:
                                mid=0.5*(self.V[i]+self.V[i+5])
                            elif i==3:
                                mid=0.5*(self.V[3]+self.V[4])
                            elif i==4:
                                mid=0.5*(self.V[0]+self.V[2])
                            else:
                                mid=0.5*(self.V[4]+self.V[6])
                            mid,fm=self.adjust(mid,self.f(mid,*args,**kwargs))
                            if fm*fc<0:
                                self.done=False
                                break
                        if self.done:
                            for i in range(12):
                                if i in [0,1,2]:
                                    mid=0.5*(self.V[i]+self.V[i+1])
                                elif i==3:
                                    mid=0.5*(self.V[3]+self.V[0])
                                elif i in [4,7]:
                                    mid=0.5*(self.V[i]+self.V[i-4])
                                elif i in [8,9,10]:
                                    mid=0.5*(self.V[i-4]+self.V[i-3])
                                else:
                                    mid=0.5*(self.V[7]+self.V[4])
                                mid,fm=self.adjust(mid,self.f(mid,*args,**kwargs))
                                if fm*fc<0:
                                    self.done=False
                                    break
            
            def split(self,C):
                if not self.done and not self.full:
                    splitC=[]
                    for c in [cube(0.5*(self.V[0]+self.V[i]),self.deltax/2,self.deltay/2,self.deltaz/2,self.f) for i in range(8)]:
                        c.calc()
                        if not c.done:
                            splitC.append(c)
                    C+=splitC
                elif self.full:
                    C+=[self]
            
            def findpoints(self):
                if not self.done and not self.full:
                    index=0
                    for i in range(8):
                        if self.F[i]<=self.zero:
                            index+=2**(7-i)
                    path=paths[index]
                    for p in path:
                        if len(p)>1:
                            for e in p[:-1]:
                                if 0<=e<=2 or 4<=e<=6:
                                    self.intersect(self.V[e],self.V[e+1],self.F[e],self.F[e+1],self.Px,self.Py,self.Pz,mode=mode)
                                elif e==3 or e==7:
                                    self.intersect(self.V[e],self.V[e-3],self.F[e],self.F[e-3],self.Px,self.Py,self.Pz,mode=mode)
                                else:
                                    self.intersect(self.V[e-8],self.V[e-4],self.F[e-8],self.F[e-4],self.Px,self.Py,self.Pz,mode=mode)
                    
            def draw(self,plotaxis):
                if not self.done:
                    if self.full:
                        if colormap is not None:
                            try:
                                self.drawbox(plotaxis,colormap((0.5*(self.V[0][2]+self.V[6][2])-start[2])/(stop[2]-start[2])),alpha)
                            except:
                                self.drawbox(plotaxis,color,alpha)
                        else:
                            self.drawbox(plotaxis,color,alpha)
                        self.done=True
                    else:
                        if len(self.Px)>0:
                            if surface:
                                poly=art3d.Poly3DCollection([[[self.Px[i],self.Py[i],self.Pz[i]] for i in range(len(self.Px))]],linewidths=1,zorder=self.viewVal,alpha=alpha)
                                if colormap is not None:
                                    try:
                                        poly.set_facecolor(colormap((sum(self.Pz)/len(self.Pz)-start[2])/(stop[2]-start[2])))
                                    except:
                                        poly.set_facecolor(color)
                                else:
                                    poly.set_facecolor(color)
                                if wireframe:
                                    if color=="black" and colormap is None:
                                        poly.set_edgecolor("white")
                                    else:
                                        poly.set_edgecolor("black")
                                else:
                                    poly.set_edgecolor("face")
                                plotaxis.add_collection3d(poly)
                            else:
                                if colormap is not None:
                                    try:
                                        plotaxis.plot(self.Px+[self.Px[0]],self.Py+[self.Py[0]],self.Pz+[self.Pz[0]],zorder=self.viewVal,color=colormap((sum(self.Pz[:-1])/len(self.Pz[:-1])-start[2])/(stop[2]-start[2])),alpha=alpha)
                                    except:
                                        plotaxis.plot(self.Px+[self.Px[0]],self.Py+[self.Py[0]],self.Pz+[self.Pz[0]],zorder=self.viewVal,color=color,alpha=alpha)
                                else:
                                    plotaxis.plot(self.Px+[self.Px[0]],self.Py+[self.Py[0]],self.Pz+[self.Pz[0]],zorder=self.viewVal,color=color,alpha=alpha)
                
            def drawbox(self,plotaxis,color,alpha):
                if surface:
                    box=art3d.Poly3DCollection([[[self.V[i][0],self.V[i][1],self.V[i][2]] for i in [0,1,2,3]],
                                                [[self.V[i][0],self.V[i][1],self.V[i][2]] for i in [0,1,5,4]],
                                                [[self.V[i][0],self.V[i][1],self.V[i][2]] for i in [1,2,6,5]],
                                                [[self.V[i][0],self.V[i][1],self.V[i][2]] for i in [2,3,7,6]],
                                                [[self.V[i][0],self.V[i][1],self.V[i][2]] for i in [0,3,7,4]],
                                                [[self.V[i][0],self.V[i][1],self.V[i][2]] for i in [4,5,6,7]]],
                                                linewidths=1,zorder=self.viewVal,color=color,alpha=alpha)
                    if wireframe:
                        if color!="black":
                            box.set_edgecolor("black")
                        else:
                            box.set_edgecolor("white")
                    else:
                        box.set_edgecolor("face")
                    plotaxis.add_collection3d(box)
                else:
                    plotaxis.plot([self.V[0][0],self.V[1][0],self.V[5][0],self.V[1][0],self.V[2][0],self.V[6][0],self.V[2][0],self.V[3][0],self.V[7][0],self.V[3][0],self.V[0][0],self.V[4][0],self.V[5][0],self.V[6][0],self.V[7][0],self.V[4][0]],
                                  [self.V[0][1],self.V[1][1],self.V[5][1],self.V[1][1],self.V[2][1],self.V[6][1],self.V[2][1],self.V[3][1],self.V[7][1],self.V[3][1],self.V[0][1],self.V[4][1],self.V[5][1],self.V[6][1],self.V[7][1],self.V[4][1]],
                                  [self.V[0][2],self.V[1][2],self.V[5][2],self.V[1][2],self.V[2][2],self.V[6][2],self.V[2][2],self.V[3][2],self.V[7][2],self.V[3][2],self.V[0][2],self.V[4][2],self.V[5][2],self.V[6][2],self.V[7][2],self.V[4][2]],
                                  zorder=self.viewVal,color=color,alpha=alpha)
                    
        if adapt:
            delta=[max((stop[i]-start[i])/5,delta[i]) for i in range(3)]
        else:
            delta=[max((stop[i]-start[i])/30,delta[i]) for i in range(3)]
        Sv1=[]
        for i in range(round((stop[0]-start[0])/delta[0])):
            for j in range(round((stop[1]-start[1])/delta[1])):
                for k in range(round((stop[2]-start[2])/delta[2])):
                    Sv1.append(np.array([start[0]+delta[0]*i,start[1]+delta[1]*j,start[2]+delta[2]*k]))
        
        C=[cube(s,delta[0],delta[1],delta[2],f) for s in Sv1]
        for c in C:
            c.calc()
    
        if adapt:
            for i in range(maxlevel-1):
                newC=[]
                for c in C:
                    c.split(newC)
                C=[c for c in newC]    
        
        for c in C:
            c.findpoints()
        
        if plotbool:
            if wireframe or surface:
                for c in C:
                    c.draw(plotaxis)
            else:
                Px,Py,Pz=[],[],[]
                for c in C:
                    for i in range(len(c.Px)):
                        matchbool=False
                        for j in range(len(Px)):
                            if abs(c.Px[i]-Px[j])<=c.zero and abs(c.Py[i]-Py[j])<=c.zero and abs(c.Pz[i]-Pz[j])<=c.zero:
                                matchbool=True
                                break
                        if not matchbool:
                            Px.append(c.Px[i])
                            Py.append(c.Py[i])
                            Pz.append(c.Pz[i])
                if colormap is not None:
                    try:
                        plotaxis.scatter(Px,Py,Pz,color=[colormap((pz-start[2])/(stop[2]-start[2])) for pz in Pz],alpha=alpha)
                    except:
                        plotaxis.scatter(Px,Py,Pz,color=color,alpha=alpha)
                else:
                    plotaxis.scatter(Px,Py,Pz,color=color,alpha=alpha)
            if plotshowbool:
                plt.show()
        else:
            Px,Py,Pz=[],[],[]
            for c in C:
                for i in range(len(c.Px)):
                    matchbool=False
                    for j in range(len(Px)):
                        if abs(c.Px[i]-Px[j])<=c.zero and abs(c.Py[i]-Py[j])<=c.zero and abs(c.Pz[i]-Pz[j])<=c.zero:
                            matchbool=True
                            break
                    if not matchbool:
                        Px.append(c.Px[i])
                        Py.append(c.Py[i])
                        Pz.append(c.Pz[i])
            return Px,Py,Pz
